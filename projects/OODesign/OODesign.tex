\documentclass{article}
\usepackage{mathtools}
\usepackage{tikz-cd}
\usepackage{adjustbox}
%\usepackage{a4wide}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{parallel,enumitem}

\DeclarePairedDelimiter\abs{\lvert}{\rvert}
\newcommand{\ddx}{\frac{d}{dx}}

\usepackage{fullpage}


\begin{document}
\includegraphics[width=2em]{2ljhyisqtna51.png}
\begin{center}
    \vspace*{\fill}
    {\Huge Object Oriented principles and design.}\newline
    {\small I am in pain.}
    \vspace*{\fill}
\end{center}
\newpage

\begin{enumerate}
    \item[\huge{Solid:}]
          {\huge S}ingle Responsibility Principle (SRP):\newline
          A class should only have a single responsibility, and only one reason to change.

              {\huge O}pen-Closed Principle (OCP):\newline
          Objects should be open to extension but closed for modification.

              {\huge L}iskov Substitution Principle (LSP)(VG):\newline
          Every subclass or derieved class should be able to substitue
          for their base or super class.

              {\huge I}nterface Segregation Principle (ISP):\newline
          A client should never be forced to implement an interface that it doesn't use, nor
          should clients be forced to depend on methods they do not use. Many
          client-specific interfaces are better then one general-purpose interface.

              {\huge D}ependency Inversion Principle (DIP):\newline
          One should depend on abstractions, rather than on concretions.

    \item[\huge Other:]
          \textbf{Seperation of Concern} (SoC):\newline
          Concerns of the software should be split up into individual parts.
          One should not write their software as one giant block and should instead
          split the code into smaller more distinctive parts.

          \textbf{Command-Query Separation Principle} (CQSP):\newline
          A method should either return data or modify data(void in most cases),
          but not both.\newline
          Something that breaks this principle is for example the \fbox{pop()} method, that
          exists for lists in many languages, because it both modifies the list by removing
          the last index and then it returns that data. This is however allowed because there
          simply is no better solution.

          \textbf{High Cohesion, Low Coupling} (HCLC):\newline
          Low Coupling: Modules and classes should be as independent from each other as possible.
          \newline
          High Cohesion: Related code should be close together. For example all methods
          in a module should be related to the modules distinct task.

          \textbf{Composition over Inheritance} (CoI):\newline
          Classes should preferably contain other classes that implement needed behavior rather
          then inheriting behavior.

          \textbf{Law of Demeter} (LoD):\newline
          To avoid loose coupling classes should only talk to their immediate "friends".\newline
          For example: instead of writing \fbox{a.b.c.d()} one should do \fbox{a.tellBtoTellCtoDoD()},
          as one should avoid relying on other classes implementation. This also ties into
          information hiding, as in for example if something doesn't need to be \fbox{public} it shouldn't
          be \fbox{public}. Package- or class-private should always be prefered.

          \textbf{Defensive Programming} (DP):\newline
          Software and libraries should be written as if the user \textbf{will} use it wrongly.
          For example, if data should only gettable instead of settable, a getter method
          should be implemented and the data should be hidden.
\end{enumerate}
\newpage

\begin{center}
    {\huge Design Patterns}
\end{center}
\begin{Parallel}[v]{0.48\textwidth}{0.48\textwidth}
    \ParallelLText{
        \textbf{Template Method}\newline
        This pattern suggests that you break down your algorithms into smaller steps, and
        each step is it's own method. These may either be abstract or inheritable, but the idea
        is that the client supply their own subclasses with their own implementations of the steps.

        \textbf{Bridge}\newline
        The bridge pattern is a design pattern used
        in software engineering that is meant to
        "decouple an abstraction from its implementation
        so that the two can vary independently".
        The bridge uses encapsulation, aggregation,
        and can use inheritance to separate
        responsibilities into different classes.


        \textbf{Strategy}\newline
        This suggests that algorithms should be able to be selected during runtime.
        Instead of implenting a single algorithm directly, an algorithms should be abled to be
        selected during runtime.

        \textbf{State}\newline
        This allows objects to change their behaviour when its internal state changes. This could be
        seen as an implementation of the Strategy Pattern.

        \textbf{Decorator}\newline
        Decorator pattern allows for objects to implement behavior dynamically without
        affecting other objects of the same class. This can be useful for the Single Responsibility
        Principle as it allows for objects to have dynamic different areas of concerns, without
        the need for subtyping.

        \textbf{Adapter}\newline
        This is used to wrap an interface of another class to be used as another interface.
        It's used to make existing classes work with each other without modifying their source code.

        \textbf{Factory (Method)}\newline
        The factory method pattern is a creational pattern
        that uses factory methods to deal with
        the problem of creating objects without having to specify
        the exact class of the object that will be created.
        This is done by creating objects by calling a factory
        method—either specified in an interface and implemented
        by child classes, or implemented in a base class and
        optionally overridden by derived classes—rather than by calling a constructor.
    }
    \ParallelRText{
        \textbf{Singleton}\newline
        This restricts a class to only be created once.
        This is used to coordinate actions across the whole program easily.
        Could be considered a "Global State". Often critized however.

        \textbf{Iterator}\newline
        In object-oriented programming, the iterator pattern is a
        design pattern in which an iterator is used to traverse a
        container and access the container's elements.
        The iterator pattern decouples algorithms from containers;
        in some cases, algorithms are necessarily container-specific
        and thus cannot be decoupled.

        \textbf{Composite}\newline
        This is a structural pattern where a group of objects are treated in a similar way as a
        single object. This is often represented as a tree structure.

        \textbf{Module}\newline
        This design pattern is used to wrap a set of function, variables and classes
        in a module, similarly to packagess in Java.

        \textbf{Facade}\newline
        A facade is an object that serves as a front-facing inteface used to mask
        more complex underlying code.

        \textbf{Model-View-Controller}\newline
        \underline{Model}\\
        The central component of the pattern.
        It is the application's dynamic data structure,
        independent of the user interface.
        It directly manages the data, logic and rules of the application.\\
        \underline{View}\\
        Any representation of information such as a chart,
        diagram or table. Multiple views of the same
        information are possible, such as a bar chart
        for management and a tabular view for accountants.\\
        \underline{Controller}\\
        Accepts input and converts it to commands for the model or view.

        \textbf{Observer}\newline
        The observer pattern is a software design pattern in which an object, named the subject, maintains a list of its dependents, called observers, and notifies them automatically of any state changes, usually by calling one of their methods.
    }
    \ParallelPar
\end{Parallel}
\newpage


\begin{center}
    {\huge Design Patterns (VG)}
\end{center}
\begin{Parallel}[v]{0.48\textwidth}{0.48\textwidth}
    \ParallelLText{
        \textbf{Entity}\newline
        Ko

        \textbf{Aggregate}\newline
        Ko

        \textbf{Chain-of-Responsibility}\newline
        The Chain-of-Responsibility pattern consists of a source of command objects
        and a series of processing objects. Each processing objects contains logic that
        defines the types of command objectss that it can handle, and the rest are passed to the
        next procesor in the chain. There should also be a mechanism for adding new processing
        objects to the end of the chain.

        \textbf{Visitor}\newline
        This pattern is a way of separating an algorithm from an object structure on
        which it operates. A practical result of this separation is the ability to
        add new operations to existing object structures without modifying the structures.
        It is one way to follow the open/closed principle.

        \textbf{Abstract Factory}\newline
        This provides a way to encapsulate a group of individual factories that have
        a common theme without specifying their concrete classes.
        In normal usage,the client software creates a concrete implementation of
        the abstract factory and then uses the generic interface of the factory
        to create the concrete objects that are part of the theme. The client does
        not know (or care) which concrete objects it gets from each of these
        internal factories, since it uses only the generic interfaces of their products.
    }
    \ParallelRText{
        \textbf{Command}\newline
        This  is a behavioral design pattern in which an object is used to encapsulate
        all information needed to perform an action or trigger an event at a later time.
        This information includes the method name, the object that owns the method and
        values for the method parameters.

        \textbf{Servant}\newline
        A servant object is one that offers some functionality to a group of objects
        without defining that functionality in them. The object in question are taken
        as a parameter by the servant. For example, an object that moves polygons,
        instead of the polygons doing that themselves as that is not their area of concern.

        \textbf{Builder}\newline
        This suggets that the creation and assembling of complex objects should be
        in its own builder object, and thuss a class delegates it's creation to this object.
        By doing this the construction and representation can be separated, and the
        same construction process can be used to create different representations.

        \textbf{Mediator}\newline
        To reduce coupling objects should not communicate directly with each other,
        but instead communicate through a mediator object.

        \textbf{Publish-Subscribe}\newline
        This is a messaging pattern where senders of messages, called publishers,
        do not program the message to be sent directly to specific receivers, called
        subscribers, but instead categorize published messages into classses without
        knowledge of hich subscribers there may be. Similarly, subscribers express
        interest in one or more classes and only recieve mesages that are of interest,
        without knowledge of which publishers, if there are any.
    }
    \ParallelPar
\end{Parallel}
\newpage

\begin{center}
    {\huge Concepts}
\end{center}

\begin{Parallel}[v]{0.49\textwidth}{0.49\textwidth}
    \ParallelLText{
        \textbf{Class and object}\newline
        Ko

        \textbf{Static and dynamic type}\newline
        Ko

        \textbf{Encapsulation}\newline
        Ko

        \textbf{Specification and Implementation inheritance}\newline
        Ko

        \textbf{Static method and instance method}\newline
        Ko

        \textbf{Variables and attributes}\newline
        Ko

        \textbf{Abstract class and interface}\newline
        Ko
    }
    \ParallelRText{
        \textbf{Dynamic Binding}\newline
        Ko

        \textbf{Primitive and referencetypes}\newline
        Ko

        \textbf{Alias}\newline
        Ko

        \textbf{Super and subclass}\newline
        Ko

        \textbf{Overloading and overriding}\newline
        Ko

        \textbf{Constructor}\newline
        Ko

        \textbf{Initialization}\newline
        Ko
    }
    \ParallelPar
\end{Parallel}

%\newpage
\begin{center}
    {\huge Mechanisms and techniques}
\end{center}

\begin{Parallel}[v]{0.49\textwidth}{0.49\textwidth}
    \ParallelLText{
        \textbf{Mutability and immutability}\newline
        Ko

        \textbf{Refactoring}\newline
        Ko

        \textbf{Defensive Copying}\newline
        Ko

        \textbf{Immutable Adapters}\newline
        Ko

        \textbf{Exceptions}\newline
        Ko

        \textbf{Method Cascading}\newline
        Ko
    }
    \ParallelRText{
        \textbf{Mutate-by-copy}\newline
        Ko

        \textbf{Lambdas and function interfaces}\newline
        Ko

        \textbf{Design by contract}\newline
        Ko

        \textbf{Algebraic data type and object hierarchy(VG)}\newline
        Ko

        \textbf{Streams}\newline
        Ko

        \textbf{Threads and threadsecurity}\newline
        Ko

    }
    \ParallelPar
\end{Parallel}

%\newpage
\begin{center}
    {\huge Polymorphism and code reuse}
\end{center}
\begin{Parallel}[v]{0.49\textwidth}{0.49\textwidth}
    \ParallelLText{
        \textbf{Polymorphism}\newline
        Ko

        \textbf{Subtype-polymorphism}\newline
        Ko

        \textbf{Parametric polymorphism}\newline
        Ko

        \textbf{Ad hoc-polymorphism(VG)}\newline
        Ko

        \textbf{Co-,contra-, and invariant}\newline
        Ko

        \textbf{Delegation}\newline
        Ko
    }
    \ParallelRText{
        \textbf{Inheritance}\newline
        Ko

        \textbf{Type constructor and type parameter}\newline
        Ko

        \textbf{Type argument and Wildcards}\newline
        Ko

        \textbf{Upper and lower bounds}\newline
        Ko

        \textbf{Get-Put principle}\newline
        Ko
    }
    \ParallelPar
\end{Parallel}

\end{document}