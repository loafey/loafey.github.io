\documentclass{article}
\usepackage{mathtools}
\usepackage{tikz-cd}
\usepackage{adjustbox}
\usepackage{a4wide}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{parallel,enumitem}

\DeclarePairedDelimiter\abs{\lvert}{\rvert}
\newcommand{\ddx}{\frac{d}{dx}}

\begin{document}
\includegraphics[width=2em]{2ljhyisqtna51.png}\newline
{\small Jimdustry\newline Programming.}
\begin{center}
    \vspace*{\fill}
    {\Huge Object Oriented principles and design.}\newline
    {\small I am in pain.}
    \vspace*{\fill}
\end{center}
\newpage

\begin{enumerate}
    \item[\huge{Solid:}]
          {\huge S}ingle Responsibility Principle (SRP):\newline
          A class should only have a single responsibility, and only one reason to change.

              {\huge O}pen-Closed Principle (OCP):\newline
          Objects should be open to extension but closed for modification.

              {\huge L}iskov Substitution Principle (LSP)(*):\newline
          Every subclass or derieved class should be able to substitue
          for their base or super class.

              {\huge I}nterface Segregation Principle (ISP):\newline
          A client should never be forced to implement an interface that it doesn't use, nor
          should clients be forced to depend on methods they do not use. Many
          client-specific interfaces are better then one general-purpose interface.

              {\huge D}ependency Inversion Principle (DIP):\newline
          One should depend on abstractions, rather than on concretions.

    \item[\huge Other:]
          \textbf{Seperation of Concern} (SoC):\newline
          Concerns of the software should be split up into individual parts.
          One should not write their software as one giant block and should instead
          split the code into smaller more distinctive parts.

          \textbf{Command-Query Separation Principle} (CQSP):\newline
          A method should either return data or modify data(void in most cases),
          but not both.\newline
          Something that breaks this principle is for example the \fbox{pop()} method, that
          exists for lists in many languages, because it both modifies the list by removing
          the last index and then it returns that data. This is however allowed because there
          simply is no better solution.

          \textbf{High Cohesion, Low Coupling} (HCLC):\newline
          Low Coupling: Modules and classes should be as independent from each other as possible.
          \newline
          High Cohesion: Related code should be close together. For example all methods
          in a module should be related to the modules distinct task.

          \textbf{Composition over Inheritance} (CoI):\newline
          Classes should preferably contain other classes that implement needed behavior rather
          then inheriting behavior.

          \textbf{Law of Demeter} (LoD):\newline
          To avoid loose coupling classes should only talk to their immediate "friends".\newline
          For example: instead of writing \fbox{a.b.c.d()} one should do \fbox{a.tellBtoTellCtoDoD()},
          as one should avoid relying on other classes implementation. This also ties into
          information hiding, as in for example if something doesn't need to be \fbox{public} it shouldn't
          be \fbox{public}. Package- or class-private should always be prefered.

          \textbf{Defensive Programming} (DP):\newline
          Software and libraries should be written as if the user \textbf{will} use it wrongly.
          For example, if data should only gettable instead of settable, a getter method
          should be implemented and the data should be hidden.
\end{enumerate}
\newpage

\begin{center}
    {\huge Design Patterns}
\end{center}
\begin{Parallel}[v]{0.48\textwidth}{0.48\textwidth}
    \ParallelLText{\noindent
        \textbf{Template Method}\newline
        This method suggests that you break down your algorithms into smaller steps, and
        each step is it's own method. These may either be abstract or inheritable, but the idea
        is that the client supply their own subclasses with their own implementations of the steps.

        \textbf{Bridge}\newline
        Ko

        \textbf{Strategy}\newline
        Ko

        \textbf{State}\newline
        Ko

        \textbf{Decorator}\newline
        Ko

        \textbf{Adapter}\newline
        Ko

        \textbf{Factory (Method)}\newline
        Ko
    }
    \ParallelRText{\noindent
        \textbf{Singleton}\newline
        Ko

        \textbf{Iterator}\newline
        Ko

        \textbf{Composite}\newline
        Ko

        \textbf{Module}\newline
        Ko

        \textbf{Facade}\newline
        Ko

        \textbf{Model-View-Controller}\newline
        Ko

        \textbf{Observer}\newline
        Ko
    }
    \ParallelPar
\end{Parallel}
\newpage


\begin{center}
    {\huge Design Patterns (VG)}
\end{center}
\begin{Parallel}[v]{0.48\textwidth}{0.48\textwidth}
    \ParallelLText{\noindent
        \textbf{Entity}\newline
        Ko

        \textbf{Aggregate}\newline
        Ko

        \textbf{Chain of Responsibility}\newline
        Ko

        \textbf{Visitor}\newline
        Ko

        \textbf{Abstract Factory}\newline
        Ko
    }
    \ParallelRText{\noindent
        \textbf{Command}\newline
        Ko

        \textbf{Servant}\newline
        Ko

        \textbf{Builder}\newline
        Ko

        \textbf{Mediator}\newline
        Ko

        \textbf{Publish-Subscribe}\newline
        Ko
    }
    \ParallelPar
\end{Parallel}
\end{document}