\documentclass{article}
\usepackage{mathtools}
\usepackage{tikz-cd}
\usepackage{adjustbox}
%\usepackage{a4wide}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{parallel,enumitem}

\DeclarePairedDelimiter\abs{\lvert}{\rvert}
\newcommand{\ddx}{\frac{d}{dx}}

\usepackage{fullpage}


\begin{document}
\includegraphics[width=2em]{2ljhyisqtna51.png}
\begin{center}
    \vspace*{\fill}
    {\Huge Object Oriented principles and design.}\newline
    {\small I am in pain.}
    \vspace*{\fill}
\end{center}
\newpage

\begin{enumerate}
    \item[\huge{Solid:}]
          {\huge S}ingle Responsibility Principle (SRP):\newline
          A class should only have a single responsibility, and only one reason to change.

              {\huge O}pen-Closed Principle (OCP):\newline
          Objects should be open to extension but closed for modification.

              {\huge L}iskov Substitution Principle (LSP)(VG):\newline
          Every subclass or derieved class should be able to substitue
          for their base or super class.

              {\huge I}nterface Segregation Principle (ISP):\newline
          A client should never be forced to implement an interface that it doesn't use, nor
          should clients be forced to depend on methods they do not use. Many
          client-specific interfaces are better then one general-purpose interface.

              {\huge D}ependency Inversion Principle (DIP):\newline
          One should depend on abstractions, rather than on concretions.

    \item[\huge Other:]
          \textbf{Seperation of Concern} (SoC):\newline
          Concerns of the software should be split up into individual parts.
          One should not write their software as one giant block and should instead
          split the code into smaller more distinctive parts.

          \textbf{Command-Query Separation Principle} (CQSP):\newline
          A method should either return data or modify data(void in most cases),
          but not both.\newline
          Something that breaks this principle is for example the \fbox{pop()} method, that
          exists for lists in many languages, because it both modifies the list by removing
          the last index and then it returns that data. This is however allowed because there
          simply is no better solution.

          \textbf{High Cohesion, Low Coupling} (HCLC):\newline
          Low Coupling: Modules and classes should be as independent from each other as possible.
          \newline
          High Cohesion: Related code should be close together. For example all methods
          in a module should be related to the modules distinct task.

          \textbf{Composition over Inheritance} (CoI):\newline
          Classes should preferably contain other classes that implement needed behavior rather
          then inheriting behavior.

          \textbf{Law of Demeter} (LoD):\newline
          To avoid loose coupling classes should only talk to their immediate "friends".\newline
          For example: instead of writing \fbox{a.b.c.d()} one should do \fbox{a.tellBtoTellCtoDoD()},
          as one should avoid relying on other classes implementation. This also ties into
          information hiding, as in for example if something doesn't need to be \fbox{public} it shouldn't
          be \fbox{public}. Package- or class-private should always be prefered.

          \textbf{Defensive Programming} (DP):\newline
          Software and libraries should be written as if the user \textbf{will} use it wrongly.
          For example, if data should only gettable instead of settable, a getter method
          should be implemented and the data should be hidden.
\end{enumerate}
\newpage

\begin{center}
    {\huge Design Patterns}
\end{center}
\begin{Parallel}[v]{0.48\textwidth}{0.48\textwidth}
    \ParallelLText{
        \textbf{Template Method}\newline
        This pattern suggests that you break down your algorithms into smaller steps, and
        each step is it's own method. These may either be abstract or inheritable, but the idea
        is that the client supply their own subclasses with their own implementations of the steps.

        \textbf{Bridge}\newline
        The bridge pattern is a design pattern used
        in software engineering that is meant to
        "decouple an abstraction from its implementation
        so that the two can vary independently".
        The bridge uses encapsulation, aggregation,
        and can use inheritance to separate
        responsibilities into different classes.


        \textbf{Strategy}\newline
        This suggests that algorithms should be able to be selected during runtime.
        Instead of implenting a single algorithm directly, an algorithms should be abled to be
        selected during runtime.

        \textbf{State}\newline
        This allows objects to change their behaviour when its internal state changes. This could be
        seen as an implementation of the Strategy Pattern.

        \textbf{Decorator}\newline
        Decorator pattern allows for objects to implement behavior dynamically without
        affecting other objects of the same class. This can be useful for the Single Responsibility
        Principle as it allows for objects to have dynamic different areas of concerns, without
        the need for subtyping.

        \textbf{Adapter}\newline
        This is used to wrap an interface of another class to be used as another interface.
        It's used to make existing classes work with each other without modifying their source code.

        \textbf{Factory (Method)}\newline
        The factory method pattern is a creational pattern
        that uses factory methods to deal with
        the problem of creating objects without having to specify
        the exact class of the object that will be created.
        This is done by creating objects by calling a factory
        method—either specified in an interface and implemented
        by child classes, or implemented in a base class and
        optionally overridden by derived classes—rather than by calling a constructor.
    }
    \ParallelRText{
        \textbf{Singleton}\newline
        This restricts a class to only be created once.
        This is used to coordinate actions across the whole program easily.
        Could be considered a "Global State". Often critized however.

        \textbf{Iterator}\newline
        In object-oriented programming, the iterator pattern is a
        design pattern in which an iterator is used to traverse a
        container and access the container's elements.
        The iterator pattern decouples algorithms from containers;
        in some cases, algorithms are necessarily container-specific
        and thus cannot be decoupled.

        \textbf{Composite}\newline
        This is a structural pattern where a group of objects are treated in a similar way as a
        single object. This is often represented as a tree structure.

        \textbf{Module}\newline
        This design pattern is used to wrap a set of function, variables and classes
        in a module, similarly to packagess in Java.

        \textbf{Facade}\newline
        A facade is an object that serves as a front-facing inteface used to mask
        more complex underlying code.

        \textbf{Model-View-Controller}\newline
        \underline{Model}\\
        The central component of the pattern.
        It is the application's dynamic data structure,
        independent of the user interface.
        It directly manages the data, logic and rules of the application.\\
        \underline{View}\\
        Any representation of information such as a chart,
        diagram or table. Multiple views of the same
        information are possible, such as a bar chart
        for management and a tabular view for accountants.\\
        \underline{Controller}\\
        Accepts input and converts it to commands for the model or view.

        \textbf{Observer}\newline
        The observer pattern is a software design pattern in which an object, named the subject, maintains a list of its dependents, called observers, and notifies them automatically of any state changes, usually by calling one of their methods.
    }
    \ParallelPar
\end{Parallel}
\newpage


\begin{center}
    {\huge Design Patterns (VG)}
\end{center}

\textbf{Entity}\newline
Ko

\textbf{Aggregate}\newline
Ko

\textbf{Chain-of-Responsibility}\newline
The Chain-of-Responsibility pattern consists of a source of command objects
and a series of processing objects. Each processing objects contains logic that
defines the types of command objectss that it can handle, and the rest are passed to the
next procesor in the chain. There should also be a mechanism for adding new processing
objects to the end of the chain.


\newpage

\begin{center}
    {\huge Concepts}
\end{center}

\begin{Parallel}[v]{0.49\textwidth}{0.49\textwidth}
    \ParallelLText{
        \textbf{Class and object}\newline
        The class is like a template for objects.

        \textbf{Static and dynamic type}\newline
        Ko

        \textbf{Encapsulation}\newline
        Ko

        \textbf{Specification and Implementation inheritance}\newline
        Ko

        \textbf{Static method and instance method}\newline
        Ko

        \textbf{Variables and attributes}\newline
        Ko

        \textbf{Abstract class and interface}\newline
        Ko
    }
    \ParallelRText{
        \textbf{Dynamic Binding}\newline
        Ko

        \textbf{Primitive and referencetypes}\newline
        Ko

        \textbf{Alias}\newline
        Ko

        \textbf{Super and subclass}\newline
        Ko

        \textbf{Overloading and overriding}\newline
        Ko

        \textbf{Constructor}\newline
        Ko

        \textbf{Initialization}\newline
        Ko
    }
    \ParallelPar
\end{Parallel}

%\newpage
\begin{center}
    {\huge Mechanisms and techniques}
\end{center}

\begin{Parallel}[v]{0.49\textwidth}{0.49\textwidth}
    \ParallelLText{
        \textbf{Mutability and immutability}\newline
        Values that can be modified and or not modified(const/final).

        \textbf{Refactoring}\newline
        Alterning internal code without changing its external behavior.

        \textbf{Defensive Copying}\newline
        To ensure immutability, getter methods should return a copy instead of a reference
        the value in question.

        \textbf{Immutable Adapters}\newline
        An implementation of the adapter pattern, where an interface is created to only expose
        immutable and safe methods of the underlying class.

        \textbf{Design by contract}\newline
        This is a designphilosophy where a methods specifications are
        seen as a contract between the client and the method.\\
        "If you promise to give me two positive integers,
        I promise to give you their biggest common divisor."

        \begin{itemize}
            \item Precondition(Förvilkor): Things that must be\\fullfiled for the method to be called.
            \item Postcondition(Eftervilkor):
                  If the precondition\\is not fullfilled there is no guarantee on\\the return.\\
                  Otherwise the return should be able to be \\guaranteed.
            \item Invariant: The needed requirements should\\be in a wellformated state.
        \end{itemize}
    }
    \ParallelRText{
        \textbf{Method Cascading}\newline
        Calling multiple methods on the same object. For example:\\
        \fbox{a.b().c();} instead of \fbox{a.b();a.c();}

        \textbf{Mutate-by-copy}\newline
        Instead of mutating an object's state it should be copied with the new state.

        \textbf{Lambdas and function interfaces}\newline
        Short-form replacement for anonymous classes for interfaces with single methods:\\
        interface k \{
        int p(double g);
        \}\\
        List$<$k$>$ l = new List$<>$();\\
        l.push((double g) -$>$ {return (int)g;});

        \textbf{Exceptions}\newline
        An error that is thrown whenever something that should not happen happens.
        These should be handled using try catches(varies between languages).
    }
    \ParallelPar
\end{Parallel}

\newpage
\begin{center}
    {\huge Polymorphism and code reuse}
\end{center}
\begin{Parallel}[v]{0.49\textwidth}{0.49\textwidth}
    \ParallelLText{
        \textbf{Polymorphism}\newline
        Polymorphism is the provision of a single interface to
        entities of different types or the use of a single
        symbol to represent multiple different types.

        \textbf{Subtype-polymorphism}\newline
        Being able to take the superclass or any of its subclasses and still work.\\
        \fbox{functionThatTakesA(new BThatInheritsA())}

        \textbf{Parametric polymorphism}\newline
        The use of generics, ie \fbox{T extends A}.

        \textbf{Ad hoc-polymorphism(VG)}\newline
        Different types should be able to give defenitions of the same symbol/name without knowing of each other.\\
        (See operator overloading in C\# and type classes in Haskell)\\
        Something like this:\\\fbox{$<$T implements +$>$ T add(T x, T y) = x + y;}\\
        This is however not possible in Java.

        \textbf{Co-,contra-, and invariant}\newline
        Covariant: ? extends T \\
        Contravariant: ? super T \\
        Invariant: T (No sub or supertypes)

        \textbf{Delegation}\newline
        Delegation means handing over responsibilities for a task to another class or method.
    }
    \ParallelRText{
        \textbf{Inheritance}\newline
        Inherting means making a class a subclass of another, and inherting methods and such from the super.

        \textbf{Type constructor and type parameter}\newline
        \fbox{class Box$<$T$>$\{\}}: The T here is a type parameter.

        \textbf{Type argument and Wildcards}\newline
        \fbox{Box$<$Integer$>$ b = new Box$<>$();}:
        The Integer is in this case a type argument.\\
        Wildcards are used for creating generic declarations and method calls but not for defining generic type,
        for example: \fbox{List$<$? extends A$>$} but not \fbox{class A$<$? extends B$>$}!

        \textbf{Upper and lower bounds}\newline
        Upper bound wildcard meands \fbox{? extends Type} and lower bound means \fbox{? super Type}.

        \textbf{Get-Put principle}\newline
        Use \fbox{List$<$? super T$>$} to only be able to put data in the list and
        \fbox{List$<$? extends T$>$} to be able to get data out of the list.
    }
    \ParallelPar
\end{Parallel}

\end{document}