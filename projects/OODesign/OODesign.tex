\documentclass{article}
\usepackage{mathtools}
\usepackage{tikz-cd}
\usepackage{adjustbox}
%\usepackage{a4wide}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{parallel,enumitem}

\DeclarePairedDelimiter\abs{\lvert}{\rvert}
\newcommand{\ddx}{\frac{d}{dx}}

\usepackage{fullpage}

\def\shrug{\texttt{\raisebox{0.75em}{\char`\_}\char`\\\char`\_\kern-0.5ex(\kern-0.25ex\raisebox{0.25ex}{\rotatebox{45}{\raisebox{-.75ex}"\kern-1.5ex\rotatebox{-90})}}\kern-0.5ex)\kern-0.5ex\char`\_/\raisebox{0.75em}{\char`\_}}}


\begin{document}
\includegraphics[width=2em]{2ljhyisqtna51.png}
\begin{center}
    \vspace*{\fill}
    {\Huge Object Oriented principles and design.}\newline
    {\small I am in pain.}
    \vspace*{\fill}
    \mbox{}
    \vfill
    \begin{flushright}
        The information contained in this document might not be fully correct.\\
        If any wrongful information is found please contact me at\\
        \underline{samuel.hammersberg@gmail.com} and I will correct it.\\
        Proof read by Emmie Berger.
    \end{flushright}
\end{center}
\newpage

\begin{enumerate}
    \item[\huge{Solid:}]
        {\huge S}ingle Responsibility Principle (SRP):\newline
        A class should only have a single responsibility, and only one reason to change.

            {\huge O}pen-Closed Principle (OCP):\newline
        Objects should be open to extension but closed for modification.

            {\huge L}iskov Substitution Principle (LSP):\newline
        Every subclass or derived class should be able to substitute
        for their base or super class.

            {\huge I}nterface Segregation Principle (ISP):\newline
        A client should never be forced to implement an interface that it doesn't use, nor
        should clients be forced to depend on methods they do not use. Many
        client-specific interfaces are better then one general-purpose interface.

            {\huge D}ependency Inversion Principle (DIP):\newline
        One should depend on abstractions, rather than on concrete implementations.

    \item[\huge Other:]
        \textbf{Seperation of Concern} (SoC):\newline
        Concerns of the software should be split up into individual parts.
        One should not write their software as one giant block, but instead
        split the code into smaller more distinctive parts.

        \textbf{Command-Query Separation Principle} (CQSP):\newline
        A method should either return data or modify data(void in most cases),
        but not both.\newline
        Something that breaks this principle is for example the \fbox{pop()} method, that
        exists for lists in many languages, because it both modifies the list by removing
        the last index and then it returns that data. This is one of many exceptions to the rule.

        \textbf{High Cohesion, Low Coupling} (HCLC):\newline
        Low Coupling: Modules and classes should be as independent from each other as possible.
        \newline
        High Cohesion: Related code should be close together. For example all methods
        in a module should be related to the modules distinct task.

        \textbf{Composition over Inheritance} (CoI):\newline
        Classes should preferably contain other classes that implement needed behavior rather
        then inheriting behavior.

        \textbf{Law of Demeter} (LoD):\newline
        To avoid loose coupling, classes should only talk to their immediate "friends".\newline
        For example: instead of writing \fbox{a.b.c.d()} one should do \fbox{a.tellBtoTellCtoDoD()},
        as one should avoid relying on other classes implementation. This also ties into
        information hiding, as in for example if something doesn't need to be \fbox{public} it shouldn't
        be \fbox{public}. Package- or class-private should always be preferred.

        \textbf{Defensive Programming} (DP):\newline
        Software and libraries should be written as if the user \textbf{will} use it wrongly.
        For example, if data should only gettable instead of settable, a getter method
        should be implemented and the data should be hidden.
\end{enumerate}
\newpage

%\begin{center}
%    {\huge Design Patterns}
%\end{center}
%\begin{Parallel}[v]{0.48\textwidth}{0.48\textwidth}
%    \ParallelLText{
%        \textbf{Template Method}\newline
%        This pattern suggests that you break down your algorithms into smaller steps, and
%        each step is it's own method. These may either be abstract or inheritable, but the idea
%        is that the client supply their own subclasses with their own implementations of the steps.
%
%        \textbf{Bridge}\newline
%        The bridge pattern is a design pattern used
%        in software engineering that is meant to
%        "decouple an abstraction from its implementation
%        so that the two can vary independently".
%        The bridge uses encapsulation, aggregation,
%        and can use inheritance to separate
%        responsibilities into different classes.
%
%
%        \textbf{Strategy}\newline
%        This suggests that algorithms should be able to be selected during runtime.
%        Instead of implementing a single algorithm directly, an algorithms should be abled to be
%        selected during runtime.
%
%        \textbf{State}\newline
%        This allows objects to change their behavior when its internal state changes. This could be
%        seen as an implementation of the Strategy Pattern.
%
%        \textbf{Decorator}\newline
%        Decorator pattern allows for objects to implement behavior dynamically without
%        affecting other objects of the same class. This can be useful for the Single Responsibility
%        Principle as it allows for objects to have dynamic different areas of concerns, without
%        the need for subtyping.
%
%        \textbf{Adapter}\newline
%        This is used to wrap an interface of another class to be used as another interface.
%        It's used to make existing classes work with each other without modifying their source code.
%
%        \textbf{Factory (Method)}\newline
%        The factory method pattern is a creation pattern
%        that uses factory methods to deal with
%        the problem of creating objects without having to specify
%        the exact class of the object that will be created.
%        This is done by creating objects by calling a factory
%        method—either specified in an interface and implemented
%        by child classes, or implemented in a base class and
%        optionally overridden by derived classes—rather than by calling a constructor.
%    }
%    \ParallelRText{
%        \textbf{Singleton}\newline
%        This restricts a class to only be created once.
%        This is used to coordinate actions across the whole program easily.
%        Could be considered a "Global State". Often criticized however as it leads
%        to a lot of tight coupling with the Singleton.
%
%        \textbf{Iterator}\newline
%        In object-oriented programming, the iterator pattern is a
%        design pattern in which an iterator is used to traverse a
%        container and access the container's elements.
%        The iterator pattern decouples algorithms from containers;
%        in some cases, algorithms are necessarily container-specific
%        and thus cannot be decoupled. For example, an object that sorts
%        a list no matter the type of list used.
%
%        \textbf{Composite}\newline
%        This is a structural pattern where a group of objects are treated in a similar way as a
%        single object. This is often represented as a tree structure.
%
%        \textbf{Module}\newline
%        This design pattern is used to wrap a set of function, variables and classes
%        in a module, similarly to packages in Java.
%
%        \textbf{Facade}\newline
%        A facade is an object that serves as a front-facing interface used to mask
%        more complex underlying code. An implementation of the Aggregate pattern.
%
%        \textbf{Model-View-Controller}\newline
%        \underline{Model}\\
%        The central component of the pattern.
%        It is the application's dynamic data structure,
%        independent of the user interface.
%        It directly manages the data, logic and rules of the application.\\
%        \underline{View}\\
%        Any representation of information such as a chart,
%        diagram or table. Multiple views of the same
%        information are possible, such as a bar chart
%        for management and a tabular view for accountants.\\
%        \underline{Controller}\\
%        Accepts input and converts it to commands for the model or view.
%
%        \textbf{Observer}\newline
%        The observer pattern is a software design pattern in which an object,
%        named the subject, maintains a list of its dependents, called observers,
%        and notifies them automatically of any state changes, usually by calling
%        one of their methods.
%    }
%    \ParallelPar
%\end{Parallel}
%\newpage
%
%\begin{center}
%    {\huge Design Patterns (VG)}
%\end{center}
%
%\textbf{Entity}\newline
%If we have data stored on disk, using xml for example, we may want to implement an Entity class
%which provides an interface for accessing and manipulating the data while hiding the underlying
%storage parts.\\
%"A design pattern for logically representing data and decoupling the persistance of data from the application view of that data."
%
%\textbf{Aggregate}\newline
%Taking a cluster or group of entities and behaviors and treating them as one cohesive unit.
%The cluster has one aggregate root or primary entity, that has the child objects and
%working with them all to implement required behavior.
%
%\textbf{Chain-of-Responsibility}\newline
%The Chain-of-Responsibility pattern consists of a source of command objects
%and a series of processing objects. Each processing objects contains logic that
%defines the types of command objects that it can handle, and the rest are passed to the
%next processor in the chain. There should also be a mechanism for adding new processing
%objects to the end of the chain.


\newpage
\begin{center}
    {\huge Concepts}
\end{center}

\begin{Parallel}[v]{0.49\textwidth}{0.49\textwidth}
    \ParallelLText{
        \textbf{Class and object}\newline
        "The class is the template used to create objects." It can also contain
        its own static methods and fields.

        \textbf{Static and dynamic type}\newline
        Static typed languages are those in which type checking is done at compile-time,
        whereas dynamic typed languages are those in which type checking is
        done at run-time. Left side is static, and dynamic is right side.

        \textbf{Encapsulation}\newline
        Encapsulation means wrapping data together as a single unit. Specifically data should also be
        hidden and getters should be supplied.

        \textbf{Specification and Implementation inheritance}\newline
        Implementing an interface or abstract class or inherting code from classes/abstract classes.

        \textbf{Static method and instance method}\newline
        Static methods are methods that can be used without an instance,
        while an instance method requires an instance of it's class to be executed.

        \textbf{Variables and attributes}\newline
        Attributes are instance variables, meaning they are defined for each object of the class.
        Variables (more precisely local variables) stores values in a method and only can be accessed in the method.

        \textbf{Abstract class and interface}\newline
        An interface is a form of specification inheritance that specifies what methods a class needs to have.
        Similarly an abstract class can do this while also having methods and attributes
        that are inherited. An abstract class can be used as a static but not dynamic type when creating objects.

        \textbf{Dynamic Binding}\newline
        Also called late binding, and this is done when you are overriding inherited public methods
        as the method used is decided during runtime.\\
        The opposite of this is static binding which is done with static, private and final methods
        as they cannot be overridden.
    }
    \ParallelRText{
        \textbf{Primitive and referencetypes}\newline
        Primitive types are types such as booleans, integers and floats, and they are stored on the stack.\\
        Reference types are types such as Classes, which are stored on the heap, and when these
        are passed around you are actually passing around copies of the\\
        reference to the object in question.

        \textbf{Alias}\newline
        Alias is when two variables point to the same object.
        (They have a copy of the same reference.)
        \\
        \fbox{A a = new A();\\A b = a;}

        \textbf{Super and subclass}\newline
        When inheriting or implementing another\\
        class/interface onto a class, the implementation is a\\
        super class and the class implementing said\\
        class/interface is the subclass.

        \textbf{Overloading and overriding}\newline
        Overloading means having multiple methods \\
        (or constructors) with the same name, but with different arguments.\\
        Overriding means replacing an inherited method or constructor with a new implementation
        (or even using the old one in the new one), also known as dynamic or late binding.

        \textbf{Constructor}\newline
        A specialized method used for initialization of new Objects of a Class.

        \textbf{Initialization}\newline
        This means assigning a value to an attribute or variable, used in constructors for example.
    }
    \ParallelPar
\end{Parallel}

\newpage
\begin{center}
    {\huge Mechanisms and techniques}
\end{center}

\begin{Parallel}[v]{0.49\textwidth}{0.49\textwidth}
    \ParallelLText{
        \textbf{Mutability and immutability}\newline
        Values that can be modified are mutable while values that cannot be modified are called immutable.

        \textbf{Refactoring}\newline
        Altering internal code without changing its external behavior.

        \textbf{Defensive Copying}\newline
        To ensure immutability, getter methods should return a copy instead of a reference
        the value in question.

        \textbf{Immutable Adapters}\newline
        An implementation of the adapter pattern, where an interface is created to only expose
        immutable and safe methods of the underlying class.

        \textbf{Design by contract}\newline
        This is a design philosophy where a methods specifications are
        seen as a contract between the client and the method.\\
        "If you promise to give me two positive integers,
        I promise to give you their biggest common divisor."

        %\begin{itemize}
        $\bullet$ Precondition(Förvilkor): Things that must be\\fullfil for the method to be called.

        $\bullet$ Postcondition(Eftervilkor):
        If the precondition\\is not fulfilled there is no guarantee on\\the return.\\
        Otherwise the return should be able to be \\guaranteed.

        $\bullet$ Invariant: Something that is always true no matter the circumstances, \\
        for example that a divider cannot be zero.
        %\end{itemize}
    }
    \ParallelRText{
        \textbf{Method Cascading}\newline
        Calling multiple methods on the same object. For example:\\
        \fbox{a.b().c();} instead of \fbox{a.b();a.c();}

        \textbf{Mutate-by-copy}\newline
        Instead of mutating an object's state it should be copied with the new state.

        \textbf{Lambdas and function interfaces}\newline
        Short-form replacement for anonymous classes for interfaces with single methods:\\
        interface k \{
        int p(double g);
        \}\\
        List$<$k$>$ l = new List$<>$();\\
        l.push((double g) -$>$ {return (int)g;});

        \textbf{Exceptions}\newline
        An error that is thrown whenever something that should not happen happens.\\
        These should be handled using try catches(varies between languages). \\
        Typically used for handling indata from users.
    }
    \ParallelPar
\end{Parallel}

\newpage
\begin{center}
    {\huge Polymorphism and code reuse}
\end{center}
\begin{Parallel}[v]{0.49\textwidth}{0.49\textwidth}
    \ParallelLText{
        \textbf{Polymorphism}\newline
        Polymorphism is the provision of a single interface to
        entities of different types or the use of a single
        symbol to represent multiple different types.

        \textbf{Subtype-polymorphism}\newline
        Being able to replace an object of a superclass with an object of it's subclass.\\
        \fbox{functionThatTakesA(new BThatInheritsA())}

        \textbf{Parametric polymorphism}\newline
        The use of generics, ie \fbox{T extends A}.

        \textbf{Ad hoc-polymorphism}\newline
        Different types should be able to give definitions of the same symbol/name without knowing of each other.\\
        (See operator overloading in C\# and type classes in Haskell)\\
        Something like this:\\\fbox{$<$T implements +$>$ T add(T x, T y) = x + y;}\\
        This is however not possible in Java.

        \textbf{Co-,contra-, and invariant}\newline
        Covariant: ? extends T \\
        Contravariant: ? super T \\
        Invariant: T (No sub or supertypes)

        \textbf{Delegation}\newline
        Delegation means handing over responsibilities for a task to another class or method.
    }
    \ParallelRText{
        \textbf{Inheritance}\newline
        Inheritance means that a subclass inherits (non-private) methods, attributes etc from the superclass.

        \textbf{Type constructor and type parameter}\newline
        \fbox{class Box$<$T$>$\{\}}: The T here is a type parameter.\\
        Type constructor is a \shrug.

        \textbf{Type argument and Wildcards}\newline
        \fbox{Box$<$Integer$>$ b = new Box$<>$();}:
        The Integer is in this case a type argument.\\
        Wildcards are used for creating generic declarations and method calls but not for defining generic type,
        for example: \fbox{List$<$? extends A$>$} but not \fbox{class A$<$? extends B$>$}!

        \textbf{Upper and lower bounds}\newline
        Upper bound wildcard means \fbox{? extends Type} and lower bound means \fbox{? super Type}.

        \textbf{Get-Put principle}\newline
        Use \fbox{List$<$? super T$>$} to only be able to put data in the list and
        \fbox{List$<$? extends T$>$} to be able to get data out of the list.
    }
    \ParallelPar
\end{Parallel}

\end{document}